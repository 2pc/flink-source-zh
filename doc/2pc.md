### 两阶段提交(2PC)

两阶段提交(2PC)是最基础的分布式一致性协议，Flink主要用它来实现exactly once，完成事务性写入。

首先，我们必须知道，在分布式环境中，为了让每个节点都能感知其它节点上事务的执行情况，需要引入一个中心节点来统一协调处理所有节点的执行逻辑，这
个中心节点就叫做协调者，而其它被中心节点协调的节点就是参与者。

而两阶段提交，故名思义，就是将分布式事务划分成了两个阶段，分别是提交请求(表决)阶段和提交(执行正常或异常)阶段。其中，协调者会根据参与者对第一
阶段，也就是提交请求/表决阶段的相应来决定是否真正的执行事务，也就是第二步执行提交/执行正常阶段或是执行提交/执行异常阶段。

下面分别对这两个阶段进行介绍。

第一阶段，提交请求(表决)阶段：
  * 协调者向所有参与者发送prepare请求与事务内容，询问是否可以准备事务的提交，并等待参与者的相应;

  * 参与者执行事务中包含的操作，并记录用于回滚的undo日志和用于重放的redo日志，但是并不真正的执行提交;

  * 参与者向协调者返回事务操作的执行结果，执行成功返回yes，否则返回no;

第二阶段，提交(执行)阶段分为正常和异常两种情况：
  * 如果所有的参与者都返回yes表示事务可以被提交：协调者向所有的参与者发送提交请求，参与者收到协调者发送的提交请求后，真正的进行事务的提交操作，
  并释放其占用的事务资源，向协调者返回确认信息，协调者收到所有的参与者返回的确认信息，分布式事务成功完成;

  * 如果有参与者返回no或者是超时未返回，说明事务中断，需要回滚：协调者向所有参与者发送回滚请求，参与者收到回滚请求后，根据undo日志回滚到事务执行
  前的状态，释放占用的事务资源，并向协调者返回ack，协调者收到所有参与者的ack信息，事务回滚完成;

从上面的介绍可以看出，2PC的实现非常简单，当然也存在一定的缺陷：
  * 协调者存在单点故障，如果协调者宕机，则整个2PC逻辑就完全不能运行;

  * 整个执行过程完全同步，参与者在等待其它参与者响应时都处于阻塞状态，高并发场景下存在性能问题;

  * 依然可能存在不一致的风险，比如如果在第二阶段由于网络或其它原因，只有部分参与者收到了commit请求，此时就会造成部分参与者进行了事务的提交而其它
  参与者未提交的情况;

Flink作为一款时下最火爆的流式处理引擎，能够提供exactly once的语义保证，仅仅flink内部是精确一次的实际上没有多大的意义，因此人们提出的端到端的
exactly once语义保证，即输入、处理程序、输出这个三个部分协同作用，共同实现整个流程的精确一次语义。
