### Flink数据通信

从数据源开始分析数据通信的整个过程，SourceFunction接口中的SourceContext内部接口SourceContext的collect()方法用于发射
数据，其实现类NonTimestampContext的collect()方法直接调用了output对象的collect方法，它是Output<StreamRecord<T>>类
型，它的实际类型是CountingOutput类型，这是一个包装类型，是对Output的包装，并在此基础上增加了收集元素数量的numRecordsOut
的Counter类型的监控变量，collect()方法中调用了numRecordsOut.inc()方法来对元素数量进行自增，从而实现了对收集元素数量的监
控。NoTimestampContext的CountingOutput封装的output的真正类型是RecordWriterOutput类型，其collect()方法会直接过滤
掉输出到其它旁路input的数据，而对于输出到非旁路input的数据则直接使用pushToRecordWriter()方法进行序列化代理，并将数据传递
给recordWriter。

RecordWriter会对数据进行序列化，然后写到缓存中，它是一个接口，有两个定义为final的实现类：
* BroadcastRecordWriter：主要用于广播模式下，维护了多个下游channel，在发送时会将数据发往下游所有的channel中；
* ChannelSelectorRecordWriter：它是一个通用的面向记录的运行时结果输出器，通过channelSelector对象来判断需要将数据发往
下游哪个channel中。keyby算子中就用到了这种RecordWriter。

以ChannelSelectorRecordWriter类为例进行分析，在其emit()方法中，其调用了父类RecordWriter的方法。传入了两个参数，分别是
需要发送的消息和调用channelSelector.selectChannel()方法根据消息和下游channel的对应关系得到的目标channel的编号。

在父类RecordWriter的emit()方法中首先使用序列化器将消息序列化，然后调用copyFromSerializerToTargetChannel()方法从序列化
器中复制数据到目标channel，深入的来分析下这个方法：首先调用serializer的reset()方法将其内部的data buffer position重置为0，
这样就可以将序列化后的结果拷贝到多个目标buffer中去。通过getBufferBuilder()获取目标channel的bufferBuilder，bufferBuilder
维护了MemorySegment内存片段，这是Flink进行内存管理的基本单位，Flink中的内存管理依赖于它并由此实现堆内堆外内存的管理。在RecordWriter
中有一个bufferBuilder的数组，其长度与下游channel的数目相同，它以channel ID为下标存储着与channel对应的bufferBuilder，如果
该channel对应的bufferBuilder还不存在就会先调用requestNewBufferBuilder申请新的bufferBuilder，否则就会直接使用当前已经存在
的。在获得BufferBuilder后会复制serializer中的数据到bufferBuilder中，并循环。